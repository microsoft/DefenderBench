
import json

import gymnasium as gym
from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score

from . import detection_data, detection_data_devign
from ..utils import HistoryTracker, extract_code


class CodeVulnerabilityDetectionEnv(gym.Env):

    CLASS_LABELS = ["vulnerable", "non-vulnerable"]

    def __init__(self, data, few_shot_data=None, nb_trials=5, num_few_shots=0):
        self.data = data
        self.few_shot_data = few_shot_data
        self.num_few_shots = num_few_shots
        self.history = HistoryTracker(nb_trials)

        self.nb_steps = len(self.data)
        self.nb_trials = nb_trials

    @property
    def instructions(self):
        instructions = (
            "You need to carefully analyze whether a given source code has vulnerability or not."
            ' Your answer must be a JSON dictionary like {"answer": "vulnerable"/"non-vulnerable"} where the value must be "vulnerable" or "non-vulnerable".'
        )

        if self.few_shot_data and self.num_few_shots:
            few_shot_samples = ""
            for i in range(self.num_few_shots):
                few_shot_samples += f"Source code {i+1}:\n```\n{self.few_shot_data[i]['content']}\n```\n"
                few_shot_samples += f'Response {i+1}: {{"answer": "{self.few_shot_data[i]["label"].lower()}"}}\n'

            instructions += (
                f"\nHere are {self.num_few_shots} samples for you to understand the task:\n"
                f"{few_shot_samples}\n"
                "Now, here is the actual source code you need to analyze.\n"
            )

        return instructions

    def build_observation(self):
        return (
            f"Source code:\n```\n{self.current_sample}\n```"
        )

    def next_sample(self):
        self.sample_id += 1
        if self.sample_id >= len(self.data):
            return False

        self.current_sample = self.data[self.sample_id]["content"]
        self.sample_label = self.data[self.sample_id]["label"].lower()

        self.gold_labels.append(self.sample_label)
        self.predictions.append('')
        self.history.reset()
        self.trial_id = 0

        return True

    def reset(self):
        self.metrics = {
            "acc": 0,
            "macf1": 0,
            "macpre": 0,
            "macrec": 0,
        }

        self.gold_labels = []
        self.predictions = []
        self.sample_id = -1
        self.score = 0
        self.max_score = len(self.data)

        self.next_sample()
        info = {
            "obs": self.build_observation(),
            "instructions": self.instructions,
            "history": self.history.describe(),
            "score": 0,
            "max_score": self.max_score,
            "metrics": self.metrics,
            "last_action": None,
            "step_done": False,
            "actions": [json.dumps({'answer': label}) for label in self.CLASS_LABELS],
        }
        self.history.step(info)
        return 0, info

    def step(self, action):
        last_action = action
        action = extract_code(action, code_type="json")
        self.trial_id += 1

        prediction = ''
        done = False
        reward = 0
        try:
            prediction = json.loads(action.lower().replace("'", '"'))
            if type(prediction) is dict:
                prediction = prediction['answer']

            if prediction not in self.CLASS_LABELS:
                obs = 'Your answer is invalid. Your answer must be a JSON dictionary like {"answer": "vulnerable"/"non-vulnerable"} where the value must be either "vulnerable" or "non-vulnerable".'
                prediction = ''
            else:
                done = True
                reward = int(prediction == self.sample_label)
                obs = f"Your answer is {prediction}. "
                obs += f"This is the correct answer." if reward else f"This is the wrong answer."

        except (ValueError, IndexError, KeyError, AttributeError):
            obs = 'Your answer is invalid. Your answer must be a JSON dictionary like {"answer": "vulnerable"/"non-vulnerable"} where the value must be either "vulnerable" or "non-vulnerable".'
            prediction = ''

        if self.trial_id >= self.nb_trials:
            done = True

        if done:
            self.score += reward
            self.predictions[-1] = prediction

        acc = accuracy_score(self.gold_labels, self.predictions)
        macf1 = f1_score(self.gold_labels, self.predictions, average='macro', zero_division=0, labels=self.CLASS_LABELS)
        macpre = precision_score(self.gold_labels, self.predictions, average='macro', zero_division=0, labels=self.CLASS_LABELS)
        macrec = recall_score(self.gold_labels, self.predictions, average='macro', zero_division=0, labels=self.CLASS_LABELS)

        self.metrics = {
            "acc": float(acc),
            "macf1": float(macf1),
            "macpre": float(macpre),
            "macrec": float(macrec),
        }

        step_done = done
        if done and self.next_sample():
            obs = self.build_observation()
            done = False
            last_action = None

        info = {
            "obs": obs,
            "last_action": last_action,
            "instructions": self.instructions,
            "history": self.history.describe(),
            "score": self.score,
            "max_score": self.max_score,
            "metrics": self.metrics,
            "step_done": step_done,
            "actions": [json.dumps({'answer': label}) for label in self.CLASS_LABELS],
        }
        self.history.step(info)

        return 0, reward, done, info


class CodeVulnerabilityDetection(CodeVulnerabilityDetectionEnv):
    def __init__(self, *args, limit=None, **kwargs):
        super().__init__(detection_data.get("test", limit), *args, **kwargs)


class CodeVulnerabilityDetectionSmall(CodeVulnerabilityDetection):
    def __init__(self, *args, **kwargs):
        super().__init__(limit=100, *args, **kwargs)


class CodeVulnerabilityDetectionFewShot(CodeVulnerabilityDetection):
    def __init__(self, *args, **kwargs):
        super().__init__(few_shot_data=detection_data.get('train'), num_few_shots=4, *args, **kwargs)


class CodeVulnerabilityDetectionFewShotSmall(CodeVulnerabilityDetectionFewShot):
    def __init__(self, *args, **kwargs):
        super().__init__(limit=100, **kwargs)


# Devign
class CodeVulnerabilityDevignDetection(CodeVulnerabilityDetectionEnv):
    def __init__(self, *args, limit=None, **kwargs):
        super().__init__(detection_data_devign.get("test", limit), *args, **kwargs)


class CodeVulnerabilityDevignDetectionSmall(CodeVulnerabilityDevignDetection):
    def __init__(self, *args, **kwargs):
        super().__init__(limit=100, *args, **kwargs)


class CodeVulnerabilityDevignDetectionFewShot(CodeVulnerabilityDevignDetection):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, few_shot_data=detection_data_devign.get('train'), num_few_shots=4, **kwargs)


class CodeVulnerabilityDevignDetectionFewShotSmall(CodeVulnerabilityDevignDetectionFewShot):
    def __init__(self, *args, **kwargs):
        super().__init__(limit=100, *args, **kwargs)
