
from io import StringIO
import logging
import warnings
import gymnasium as gym
import pandas as pd

from codebleu import calc_codebleu
from Levenshtein import distance as lev
from termcolor import colored

from . import fixing_data
from ..utils import HistoryTracker, catch_logging, extract_code


class CVEFixEnv(gym.Env):

    def __init__(self, data, nb_trials=5):
        self.data = data
        self.history = HistoryTracker(nb_trials)

        self.nb_steps = len(self.data)
        self.nb_trials = nb_trials

    @property
    def instructions(self):
        return (
            "You need to carefully analyze a given snippet code and fix its vulnerability."
            " Your answer must be a markdown code block of the same snippet of code once fixed including any existing comments."
        )

    def build_observation(self):
        return (
            f"Source code:\n```{self.language}\n{self.current_sample}\n```"
        )

    def next_sample(self):
        self.sample_id += 1
        if self.sample_id >= len(self.data):
            return False

        self.record = self.data.iloc[self.sample_id]
        self.current_sample = self.record["code_before"]
        self.target = self.record["code_after"]
        self.language = self.record["programming_language"].lower()

        self.targets.append(self.target)
        self.predictions.append('')
        self.history.reset()
        self.trial_id = 0

        return True

    def reset(self):
        self.metrics = {
            "codebleu": 0,
            "ngram_match_score": 0,
            "weighted_ngram_match_score": 0,
            "syntax_match_score": 0,
            "dataflow_match_score": 0
        }

        self.targets = []
        self.predictions = []
        self.sample_id = -1
        self.score = 0
        self.max_score = len(self.data)

        self.next_sample()
        info = {
            "obs": self.build_observation(),
            "instructions": self.instructions,
            "history": self.history.describe(),
            "score": 0,
            "max_score": self.max_score,
            "metrics": self.metrics,
            "last_action": None,
            "step_done": False,
            "actions": [f"```{self.language}\n{self.current_sample}\n```"],
        }
        self.history.step(info)
        return 0, info

    def step(self, action):
        last_action = action
        self.trial_id += 1

        obs = ""
        prediction = ''
        done = False
        reward = 0

        if "```" not in action:
            obs = 'Your answer is invalid. Your answer must be a markdown code block of the entire source code once fixed including comments.'
        else:
            prediction = action = extract_code(action, code_type=self.language)
            done = True

        with catch_logging() as log:
            # Taken from CodeBLEU paper: https://arxiv.org/pdf/2009.10297
            weights = (
                0.1,  # ngram_match_score: ngram_match score (BLEU)
                0.1,  # weighted_ngram_match_score: weighted_ngram_match score (BLEU-weighted)
                0.4,  # syntax_match_score: syntax_match score (AST match)
                0.4,  # dataflow_match_score: dataflow_match score
            )
            self.metrics = calc_codebleu([self.target], [prediction], lang=self.language.replace("c++", "cpp"), weights=weights)

            log.seek(0)
            if log.read():
                weights = (
                    0.1,  # ngram_match_score: ngram_match score (BLEU)
                    0.1,  # weighted_ngram_match_score: weighted_ngram_match score (BLEU-weighted)
                    0.8,  # syntax_match_score: syntax_match score (AST match)
                    0.0,  # dataflow_match_score: dataflow_match score
                )
                self.metrics = calc_codebleu([self.target], [prediction], lang=self.language.replace("c++", "cpp"), weights=weights)

        reward = self.metrics["codebleu"]

        if self.trial_id >= self.nb_trials:
            done = True

        if done:
            self.score += reward
            self.predictions[-1] = prediction

        step_done = done
        if done and self.next_sample():
            obs = self.build_observation()
            done = False
            last_action = None

        info = {
            "obs": obs,
            "last_action": last_action,
            "instructions": self.instructions,
            "history": self.history.describe(),
            "score": self.score,
            "max_score": self.max_score,
            "metrics": self.metrics,
            "step_done": step_done,
            "actions": [f"```{self.language}\n{self.current_sample}\n```"],
        }
        self.history.step(info)

        return 0, reward, done, info


class CVEFix(CVEFixEnv):
    def __init__(self, *args, limit=None, **kwargs):
        super().__init__(fixing_data.get("test", limit), *args, **kwargs)


class CVEFixSmall(CVEFix):
    def __init__(self, *args, **kwargs):
        super().__init__(limit=100, *args, **kwargs)


# TODO: CVEFixWithContext
# TODO: CVEFixWithRepo
